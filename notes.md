## Notes for other algorithms
1. K最近邻算法(K-Nearest Neighbours, KNN)  
   1. 用于创建推荐系统，如电影推荐系统提醒你评分，你评分的电影越多，推荐系统就能判断你与哪些用户类似，用此给你推荐他们喜欢的。用户之间的相似程度可以用毕达哥拉斯公式计算（即计算两点之间的距离）,还可以使用余弦相似度（比较角度，即方向）
   2. 可以创立意见领袖，这类用户评分时的权重更大
   3. 评分方式的差异可以使用归一化解决(normalization)
   4. OCR光学字符识别一开始也是基于KNN提取特征做判断，无论多么复杂的技术都是基于KNN等简单理念的
2. 朴素贝叶斯分类器
   1. 可用于垃圾邮件过滤
3. 二叉树
   1. 平均时间复杂度是O(log n)，最糟是O(n)，当二叉树只有一个分叉时，此时就犹如一个链表
   2. 有序数组查找，最糟就是O(log n),但是二叉树的插入和删除要快很多
   3. 不能随机访问
   4. 更多树结构：
      1. B树
      2. 红黑树
      3. 堆
      4. 伸展树
4. 反向索引
   1. 根据关键词创建哈希表，常用于创建搜索引擎
5. 傅立叶变换
   1. 给他一杯冰沙，告诉你包含什么成分
   2. 用于歌曲的频率分离，处理信号，压缩音乐
6. 并行算法
   1. 分布式算法Map(映射)Reduce(归并)，可使用开源工具Apache Hadoop使用
      1. 映射是将一个数组转换为另一个数组(参考python map())
      2. 归并是将一个数组转化为一个元素(参考python reduce())
7. 布隆过滤器（一种概率型算法，用于收集网页，相比哈希表答案不一定绝对可靠，可占用空间很小）
   1. 可能错报，如指出已收集却返回未收集
   2. 不会漏报，如指出未收集就一定未收集
   3. hyperloglog类似于布隆过滤器
8. SHA算法（secure hash algorithm）
   1. 不同于普通散列函数，不生成数组索引而是另一个字符串
   2. 可以把密码转化为散列值，但反过来不行，所以服务器存储散列值
   3. 局部不敏感，原数据微小的变化将使散列字符串完全不同
9. simhash算法
   1. 局部敏感
   2. 用于论文查重
10. Diffie-Hellman密钥交换
   1. 对消息进行加密以便只有收件人能看懂
11. 线性规划
    1.  线性规划使用simplex算法
    2.  所有的图算法都可使用线性规划来实现